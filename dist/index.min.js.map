{"version":3,"file":"index.min.js","sources":["../src/WhizFlow.tsx","../src/useWhizFlow.ts"],"sourcesContent":["import React from 'react';\nimport { WhizFlowProps } from './types';\nimport { useWhizFlow } from './useWhizFlow';\n\nexport const WhizFlow: React.FC<WhizFlowProps> = ({\n  workflow,\n  questionTypes,\n  children,\n  onComplete,\n}) => {\n  const defaultOnComplete = () => {};\n  const { step, answers, setAnswers, handleNext } = useWhizFlow(\n    workflow,\n    onComplete ?? defaultOnComplete\n  );\n\n  const renderQuestion = (questionId: string) => {\n    const question = step.questions.find((q) => q.id === questionId);\n\n    if (!question) {\n      console.error(`Question with ID \"${questionId}\" not found.`);\n      return null;\n    }\n\n    if (!questionTypes) {\n      console.error(`No question types defined.`);\n      return null;\n    }\n\n    const renderFunc = questionTypes[question.inputType];\n\n    if (!renderFunc) {\n      console.error(\n        `Question type \"${question.inputType}\" not found in the provided questionTypes.`\n      );\n      return null;\n    }\n\n    return renderFunc(question, answers, setAnswers);\n  };\n\n  return children({ step, answers, setAnswers, handleNext, renderQuestion });\n};\n","// src/useWhizFlow.ts\nimport { useState } from 'react';\nimport { Step, Answers } from './types';\n\nexport const useWhizFlow = (\n  workflow: Step[],\n  onComplete: (answers: Answers) => void\n) => {\n  const [currentStep, setCurrentStep] = useState<number>(0);\n  const [answers, setAnswers] = useState<Answers>({});\n\n  const step = workflow[currentStep];\n\n  const handleNext = (submitterAnswers?: Answers) => {\n    const currAnswers = submitterAnswers ?? answers;\n    const result = step.next(currAnswers);\n\n    const nextStepId = typeof result === 'string' ? result : result.nextStepId;\n    const updatedAnswers =\n      typeof result !== 'string' && result.updatedAnswers\n        ? result.updatedAnswers\n        : currAnswers;\n\n    if (nextStepId === 'done') {\n      onComplete(updatedAnswers);\n    } else {\n      setAnswers(updatedAnswers);\n      const nextStepIndex = workflow.findIndex(\n        (step) => step.id === nextStepId\n      );\n\n      if (nextStepIndex === -1) {\n        console.error(`Error: Non-existent step \"${nextStepId}\"`);\n        return;\n      }\n\n      setCurrentStep(nextStepIndex);\n    }\n  };\n\n  return {\n    step,\n    answers,\n    setAnswers,\n    handleNext,\n  };\n};\n"],"names":["_a","workflow","questionTypes","children","onComplete","_b","useState","currentStep","setCurrentStep","answers","setAnswers","step","handleNext","submitterAnswers","currAnswers","result","next","nextStepId","updatedAnswers","nextStepIndex","findIndex","id","console","error","useWhizFlow","renderQuestion","questionId","question","questions","find","q","renderFunc","inputType","concat"],"mappings":"mDAIiD,SAACA,OAChDC,EAAQD,EAAAC,SACRC,EAAaF,EAAAE,cACbC,EAAQH,EAAAG,SACRC,EAAUJ,EAAAI,WAGJC,ECPmB,SACzBJ,EACAG,GAEM,IAAAJ,EAAgCM,EAAAA,SAAiB,GAAhDC,EAAWP,EAAA,GAAEQ,EAAcR,EAAA,GAC5BK,EAAwBC,EAAAA,SAAkB,CAAE,GAA3CG,EAAOJ,EAAA,GAAEK,EAAUL,EAAA,GAEpBM,EAAOV,EAASM,GA6BtB,MAAO,CACLI,KAAIA,EACJF,QAAOA,EACPC,WAAUA,EACVE,WA/BiB,SAACC,GAClB,IAAMC,EAAcD,QAAAA,EAAoBJ,EAClCM,EAASJ,EAAKK,KAAKF,GAEnBG,EAA+B,iBAAXF,EAAsBA,EAASA,EAAOE,WAC1DC,EACc,iBAAXH,GAAuBA,EAAOG,eACjCH,EAAOG,eACPJ,EAEN,GAAmB,SAAfG,EACFb,EAAWc,OACN,CACLR,EAAWQ,GACX,IAAMC,EAAgBlB,EAASmB,WAC7B,SAACT,GAAS,OAAAA,EAAKU,KAAOJ,CAAZ,IAGZ,IAAuB,IAAnBE,EAEF,YADAG,QAAQC,MAAM,oCAA6BN,EAAU,MAIvDT,EAAeW,EAChB,CACH,EAQF,CDnCoDK,CAChDvB,EACAG,QAAAA,EAHwB,cAClBO,EAAIN,EAAAM,KAAEF,EAAOJ,EAAAI,QAAEC,EAAUL,EAAAK,WAAEE,EAAUP,EAAAO,WA8B7C,OAAOT,EAAS,CAAEQ,KAAIA,EAAEF,QAAOA,EAAEC,WAAUA,EAAEE,WAAUA,EAAEa,eAzBlC,SAACC,GACtB,IAAMC,EAAWhB,EAAKiB,UAAUC,MAAK,SAACC,GAAM,OAAAA,EAAET,KAAOK,CAAU,IAE/D,IAAKC,EAEH,OADAL,QAAQC,MAAM,4BAAqBG,EAAU,iBACtC,KAGT,IAAKxB,EAEH,OADAoB,QAAQC,MAAM,8BACP,KAGT,IAAMQ,EAAa7B,EAAcyB,EAASK,WAE1C,OAAKD,EAOEA,EAAWJ,EAAUlB,EAASC,IANnCY,QAAQC,MACN,kBAAAU,OAAkBN,EAASK,UAAqD,+CAE3E,KAIX,GAGF"}